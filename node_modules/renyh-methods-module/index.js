/* eslint-disable */

/* 生成uuid */
export const uuid = () => { 
  let s = []
  let hexDigits = '0123456789abcdef'
  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1)
  }
  s[14] = '4' // bits 12-15 of the time_hi_and_version field to 0010
  s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1) // bits 6-7 of the clock_seq_hi_and_reserved to 01
  s[8] = s[13] = s[18] = s[23] = '-'
  let uuid = s.join('')
  return uuid
}
/* 关于cookie的相关设置 */
export const cookie = { 
  set: function (name, value, days) {
    let exp = new Date()
    exp.setTime(exp.getTime() + days * 24 * 60 * 60 * 1000)
    document.cookie = name + '=' + escape(value) + ';expires=' + exp.toGMTString() + ';path=/'
  },
  get: function (name) {
    var arr
    var reg = new RegExp('(^| )' + name + '=([^;]*)(;|$)')
    arr = document.cookie.match(reg)
    if (arr) {
      return unescape(arr[2])
    } else {
      return null
    }
  },
  delete: function (name) {
    var exp = new Date()
    exp.setTime(exp.getTime() - 1)
    var cval = this.get(name)
    if (cval !== null) {
      document.cookie = name + '=' + cval + ';expires=' + exp.toGMTString()
    }
  }
}
/* 获取URL后参数 */
export const getQuery = () => {
  let url = window.location.search
  let theRequest = {}
  if (url.indexOf('?') !== -1) {
    let str = url.substr(1)
    var strs = str.split('&')
    for (let i = 0; i < strs.length; i++) {
      theRequest[strs[i].split('=')[0]] = unescape(strs[i].split('=')[1])
    }
  }
  return theRequest
}
/* 手机号 */
export const isMobileNo = (str) => {
  return str.match(/^((13[0-9])|(14[0-9])|(15[0-3,5-9])|(16[6])|(17[0,1,3,5-8])|(18[0-9])|(19[8,9]))\d{8}$/)
}
/* 邮箱号 */
export const isEmail = (str) => {
  return str.match(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)
}
/* 时间格式化 */
export const formatDate = (fmt, date) => { 
  date = new Date(date)
  let o = {
    'M+': date.getMonth() + 1, // 月份
    'd+': date.getDate(), // 日
    'h+': date.getHours(), // 小时
    'm+': date.getMinutes(), // 分
    's+': date.getSeconds(), // 秒
    'q+': Math.floor((date.getMonth() + 3) / 3), // 季度
    'S': date.getMilliseconds() // 毫秒
  }
  if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))
  for (let k in o) {
    if (new RegExp('(' + k + ')').test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length)))
  }
  return fmt
}

export const sessionStorage = {
  set: function (name, val) {
    if (val instanceof Object) {
      val = JSON.stringify(val)
    }
    window.sessionStorage.setItem(name, val)
  },

  get: function (key) {
    let val = window.sessionStorage.getItem(key)
    if (val) {
      return val
    } else {
      return null
    }
  },

  delete: function (key) {
    window.sessionStorage.removeItem(key)
  },

  clear: function () {
    window.sessionStorage.clear()
  }
}

export const localStorage = {
  set: function (key, val) {
    if (val instanceof Object) {
      val = JSON.stringify(val)
    }
    window.localStorage.setItem(key, val)
  },
  get: function (key) {
    let val = window.localStorage.getItem(key)
    if (val) {
      return val
    } else {
      return null
    }
  },
  delete: function (key) {
    window.localStorage.removeItem(key)
  },
  clear: function () {
    window.localStorage.clear()
  }
}

export const countProperties = (o) => {
  let count = 0
  for (let property in o) {
    if (Object.prototype.hasOwnProperty.call(o, property)) {
      count++
    }
  }
  return count
}

export function find(list, f) {
  return list.filter(f)[0]
}
/* 深拷贝 */
export const deepCopy = (obj, cache) => {
  if (cache === void 0) cache = []

  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  var hit = find(cache, function (c) {
    return c.original === obj
  })
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {}
  cache.push({
    original: obj,
    copy: copy
  })

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache)
  })

  return copy
}

export const isArr = (obj) => {
  return obj.__proto__ === Array.prototype
}

export const scrollTo = (y) => {
  window.scrollTo({
    top: y,
    behavior: 'smooth'
  })
}

export const memoize = (fn) => {
  let cache = {}
  return function () {
    let key = JSON.stringify(arguments)
    let value = cache[key]
    if (!value) {
      value = [fn.apply(this, arguments)]
      cache[key] = value
    }
    return value[0]
  }
}

/* options的默认值
 *  options.leading = true; 表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。
 *
 *  options.trailing = true;
 *  表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。
 */
export const throttle = (func, wait, options) => {
  let context = undefined
  let args = undefined
  let result = undefined
  var timeout = null
  var previous = 0
  if (!options) {
    options = {}
  }

  const later = function () {
    previous = options.leading === false ? 0 : Date.parse(new Date())
    timeout = null
    result = func.apply(context, args)
    if (!timeout) {
      context = args = null
    }
  }

  return function () {
    let now = Date.parse(new Date())

    if (!previous && options.leading === false) {
      previous = now
    }

    // 计算剩余时间
    let remaining = wait - (now - previous)
    context = this
    args = arguments

    // 当到达wait指定的时间间隔，则调用func函数
    if (remaining <= 0 || remaining > wait) {
      // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔，但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作
      if (timeout) {
        clearTimeout(timeout)
        timeout = null
      }
      previous = now
      result = func.apply(context, args)

      if (!timeout) {
        context = args = null
      }

    } else if (!timeout && options.trailing !== false) {
      // options.trailing=true时，延时执行func函数
      timeout = setTimeout(later, remaining)
    }
    return result
  }
}
/* 防抖节流 */
export const debounce = (func, wait, immediate) => {
  // immediate默认为false
  let timeout = null
  let args = undefined
  let context = undefined
  let timestamp = undefined
  let result = undefined

  const later = function () {
    // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last < wait && last >= 0一直为true，从而不断启动新的计时器延时执行func
    let last = Date.parse(new Date()) - timestamp

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last)
    } else {
      timeout = null

      if (!immediate) {
        result = func.apply(context, args)

        if (!timeout) {
          context = args = null
        }
      }
    }
  }

  return function () {
    context = this
    args = arguments
    timestamp = Date.parse(new Date())

    // 第一次调用该方法时，且immediate为true，则调用func函数
    var callNow = immediate && !timeout

    // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数
    if (!timeout) {
      timeout = setTimeout(later, wait)
    }

    if (callNow) {
      result = func.apply(context, args)
      context = args = null
    }

    return result
  }
}

export const convertBase64UrlToBlob = (urlData) => {
  let arr = urlData.split(','), mime = arr[0].match(/:(.*?);/)[1]
  let bstr = atob(arr[1])
  let n = bstr.length
  let u8arr = new Uint8Array(n)
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n)
  }
  return new Blob([u8arr], { type: mime })
}
/* 获取设备信息 */
export const isMobile = () => {
  return (/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i).test(window.navigator.userAgent)
}

export const toMoney = (num, n) => {
  if (num) {
    n = n > 0 && n <= 20 ? n : 2
    num = parseFloat((num + '').replace(/[^\d\.-]/g, '')).toFixed(n) + ''
    var l = num.split('.')[0].split('').reverse(), r = num.split('.')[1]
    let t = ''
    for (let i = 0; i < l.length; i++) {
      t += l[i] + ((i + 1) % 3 === 0 && (i + 1) !== l.length ? ',' : '')
    }
    return t.split('').reverse().join('') + '.' + r
  } else {
    return 0
  }
}
/*金额小写转大写*/
export const digitUppercase = (n) => {
  var fraction = ['角', '分']
  var digit = [
    '零', '壹', '贰', '叁', '肆',
    '伍', '陆', '柒', '捌', '玖'
  ]
  var unit = [
    ['元', '万', '亿'],
    ['', '拾', '佰', '仟']
  ]
  var head = n < 0 ? '欠' : ''
  n = Math.abs(n)
  var s = ''
  for (var i = 0; i < fraction.length; i++) {
    s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, '')
  }
  s = s || '整'
  n = Math.floor(n)
  for (var i = 0; i < unit[0].length && n > 0; i++) {
    var p = ''
    for (var j = 0; j < unit[1].length && n > 0; j++) {
      p = digit[n % 10] + unit[1][j] + p
      n = Math.floor(n / 10)
    }
    s = p.replace(/(零.)*零$/, '').replace(/^$/, '零') + unit[0][i] + s
  }
  return head + s.replace(/(零.)*零元/, '元')
    .replace(/(零.)+/g, '零')
    .replace(/^整$/, '零元整')
}

/* 加减乘除 */
export const onCount = {
  /*
    说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。
    调用：add(arg1,arg2)
    返回值：arg1加上arg2的精确结果
  */
  add: function (arg1, arg2) {
    var r1, r2, m
    try {
      r1 = arg1.toString().split('.')[1].length
    } catch (e) {
      r1 = 0
    }
    try {
      r2 = arg2.toString().split('.')[1].length
    } catch (e) {
      r2 = 0
    }
    m = Math.pow(10, Math.max(r1, r2))
    return (arg1 * m + arg2 * m) / m
  },
  /*
    说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。
    调用：sub(arg1,arg2)
    返回值：arg1减去arg2的精确结果
  */
  sub: function (arg1, arg2) {
    var r1, r2, m, n
    try {
      r1 = arg1.toString().split('.')[1].length
    } catch (e) {
      r1 = 0
    }
    try {
      r2 = arg2.toString().split('.')[1].length
    } catch (e) {
      r2 = 0
    }
    m = Math.pow(10, Math.max(r1, r2))
    //last modify by deeka
    //动态控制精度长度
    n = (r1 >= r2) ? r1 : r2
    return ((arg1 * m - arg2 * m) / m).toFixed(n)
  },
  /*
    说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。
    调用：mul(arg1,arg2)
    返回值：arg1乘以arg2的精确结果
  */
  mul: function (arg1, arg2) {
    var m = 0, s1 = arg1.toString(), s2 = arg2.toString()
    try {
      m += s1.split('.')[1].length
    } catch (e) {
    }
    try {
      m += s2.split('.')[1].length
    } catch (e) {
    }
    return Number(s1.replace('.', '')) * Number(s2.replace('.', '')) / Math.pow(10, m)

  },
  /*
    说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。
    调用：div(arg1,arg2)
    返回值：arg1除以arg2的精确结果
  */
  div: function (arg1, arg2) {
    var t1 = 0, t2 = 0, r1, r2
    try {
      t1 = arg1.toString().split('.')[1].length
    } catch (e) {
    }
    try {
      t2 = arg2.toString().split('.')[1].length
    } catch (e) {
    }
    r1 = Number(arg1.toString().replace('.', ''))
    r2 = Number(arg2.toString().replace('.', ''))
    return (r1 / r2) * Math.pow(10, t2 - t1)
  }
}
/* 下载 */
export const download = (options) => {
  const uid = (new Date()).getTime()
  const {
    url,
    blob,
    title = uid
  } = options
  const a = document.createElement('a')
  a.style.display = 'none'
  a.download = title
  if (blob) {
    let newBlob = new Blob([blob])
    const blobUrl = window.URL.createObjectURL(newBlob)
    a.href = blobUrl
    a.click()
  } else if (url) {
    a.href = url
    a.click()
  }
}

export const delInArr = (arr, index) => {
  const newArr = deepCopy(arr)
  newArr.splice(index, 1)
  return newArr
}

export const hasOwnProperty = (obj, key) => {
  if (obj && obj.hasOwnProperty(key)) {
    return true
  }
  return false
}

// 嵌套对象判断
export const isContainObj = (obj, needle, keyInobj) => {
  for (let i in obj) {
    if (obj[i][keyInobj] === needle) return true
  }
  return false
}

export const sortByKey = (arr, key, type = 'asc') => {
  let newArr = deepCopy(arr)
  if (type === 'asc') {
    newArr.sort((a, b) => {
      if (a[key] < b[key]) {
        return -1
      } else if (a[key] > b[key]) {
        return 1
      } else {
        return 0
      }
    })
  } else {
    newArr.sort((a, b) => {
      if (a[key] > b[key]) {
        return -1
      } else if (a[key] < b[key]) {
        return 1
      } else {
        return 0
      }
    })
  }
  return newArr
}

export const isObject = (val) => {
  return val !== null && typeof val === 'object' && Array.isArray(val) === false
}

/*isLength：检查 value 是否为有效的类数组长度*/
export const isLength = (value) => {
  return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= Number.MAX_SAFE_INTEGER
}

/*isFunction：检查 value 是不是函数*/
export const isFunction = (value) => {
  return Object.prototype.toString.call(value) === '[object Function]'
}

/*isArrayLike：检查 value 是否是类数组*/
export const isArrayLike = (value) => {
  return value != null && isLength(value.length) && !isFunction(value)
}

/*isPlainObject：判断数据是不是Object类型的数据*/
export const isPlainObject = (obj) => {
  return Object.prototype.toString.call(obj) === '[object Object]'
}
/*
  isEmpty：检查 value 是否为空
*/
export const isEmpty = (value) => {
  if (value === null) {
    return true
  }
  if (value === undefined) {
    return true
  }
  if (isArrayLike(value)) {
    return !value.length
  } else if (isPlainObject(value)) {
    for (let key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false
      }
    }
  }
  return false
}
/*
  处理数组数量
*/
export const dealArrGroup = (array, subGroupLength) => {
  var index = 0
  var newArray = []
  while (index < array.length) {
    newArray.push(array.slice(index, index += subGroupLength))
  }
  return newArray
}

export const ConvertNumber = (number, count = 2, isSavePoint = false) => {
  if (number === undefined || number === null || number === '') {
    return number
  }
  if (typeof number == 'string' && number.includes(',')) {
    return number
  }
  number = +number
  if (!isNaN(number)) {
    if (`${number}`.includes('.')) {
      let _inter = `${number}`.split('.')[0]
      let _point = '0.' + `${number}`.split('.')[1]
      if (!isSavePoint) {
        _point = +_point
        _point = _point.toFixed(count)
        _point = '.' + `${_point}`.split('.')[1]
      }
      number = _inter.replace(/\B(?=(\d{3})+\b)/g, ",") + _point
    } else {
      number = number.toFixed(count).replace(/\B(?=(\d{3})(?=.[0-9])+\b)/g, ",")
    }
  }
  return number
}
export const ConvertPercent = (number, count = 2, removal = true) => {
  if (number === undefined) {
    return number
  }
  if (typeof number != 'string') {
    number = `${number}`
  }
  if (number.includes('%')) {
    return number
  }
  if (number.includes(',')) {
    let aValues = number.split(',')
    aValues = aValues.map((item) => {
      if (!isNaN(item)) {
        return `${(item * 100).toFixed(count)}%`
      }
    })
    if (removal) {
      aValues = [...new Set(aValues)]
    }
    number = aValues.join(',')
  } else {
    number = `${(number * 100).toFixed(count)}%`
  }
  return number
}
/*
  数组，属性，属性值
*/
export const removeByValue = (arr, attr, value) => { 
  let newarr = deepCopy(arr)
  let index = 0
  for (let i in newarr) {
    if (newarr[i][attr] === value) {
      index = i
      break
    }
  }
  return newarr.splice(index, 1)
}

export default {
  uuid,
  cookie,
  getQuery,
  isMobileNo,
  isEmail,
  formatDate,
  sessionStorage,
  localStorage,
  countProperties,
  find,
  deepCopy,
  isArr,
  scrollTo,
  memoize,
  throttle,
  debounce,
  convertBase64UrlToBlob,
  isMobile,
  toMoney,
  digitUppercase,
  onCount,
  download,
  delInArr,
  hasOwnProperty,
  isContainObj,
  sortByKey,
  isObject,
  isLength,
  isFunction,
  isArrayLike,
  isPlainObject,
  isEmpty,
  dealArrGroup,
  ConvertNumber,
  ConvertPercent,
  removeByValue,
}
